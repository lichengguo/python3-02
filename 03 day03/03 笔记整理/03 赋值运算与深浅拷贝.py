#!/usr/bin/env python3
#author:Alnk(李成果)
# 赋值运算
# 可变的数据类型:由于数据类型可变，修改数据会在原来的数据的基础上进行修改，
# 可变的数据类型有：列表，字典
# l1 = [1,2,3]
# l2 = l1
# l3 = l2
# # l1 = [1,2,3,4]     #注意这不是修改数据，而是在内存中重新创建了一份数据，然后L1 指向了这份新数据
# l1.append(666)       #在原来的数据上修改
# print(l1,l2,l3)
# print(id(l1),id(l2),id(l3))
# 不可变的数据类型:由于数据类型是不可变的，不可修改，会在内存中在重新创建一份新的数据
# 不可变的数据类型有：字符串，数字，bool值，元组等
# l4 = 'abcd'
# l5 = l4
# l4 = [1,2,3,]
# print(l4,l5)
# print(id(l4),id(l5))


# 浅copy
# copy一个新列表(dict)，列表在内存中是新的，但是列表里面的元素，完全沿用之前的元素。
# l1 = [1, 2, 3,[22,33]]
# l2 = l1.copy()
# print(id(l1),id(l2))
# l1.append(666)
# l1.remove(1)
# print(l1,l2)
# 列表在内存中是新的，但是列表里面的元素，完全沿用之前的元素
# print(id(l1[0]))
# print(id(l2[0]))
# l1[-1].append(666)
# print(l1,l2)


# 深copy
import copy
# 总结：深copy则会在内存中开辟新空间，将原列表以及列表里面的可变的数据类型重新创建一份，
# 不可变的数据类型则沿用之前的，指向之前的数据
# l1 = [1, 2, 3, [22, 33]]
# l2 = copy.deepcopy(l1)
# print(id(l1), id(l2))       #id 不一样，是两份数据
# l1[-1].append(666)
# l1.remove(1)                #只是删除了l1列表中和内存中的数据1的指向关系，并不是在内存中删除了数据1
# print(l1,l2)


# id 测试对象的内存地址
# == 比较 比较两边的数值是否相等
# print(2 == 2)
# is 判断 判断的两边对象的内存地址是否是同一个。


# ****** 切片是浅copy
# l1 = [1, 2, 3, [22, 33]]
# l2 = l1[:]  # 切片是浅copy
# l1[-1].append(666)
# # print(id(l1),id(l2)) 不是赋值关系
# print(l1,l2)