#!/usr/bin/env python3
# author:Alnk(李成果)


# 1、简述类、对象、实例化、实例是分别是什么
# 看图1
#
# class Dog:
#     x = 10
#
#     def __init__(self, name):
#         self.name = name
#
#     def bite(self):
#         print(' %s biting' % (self.name))
#
#
# d1 = Dog('tom')
# d1.bite()


# 2、请简述面向对象三大特性？
# 封装
#     在类中对 数据的赋值、内部调用 对外部用户是透明的（这里透明的意思是类的外部不能调用这些数据，但是类的内部可以调用），
#     这使类变成了一个胶囊或容器，里面包含着类的数据和方法
#
# 继承
#     一个类可以派生出子类，在这个父类里定义的属性、方法自动被子类继承
#
# 多态
#     多态是面向对象的重要特性,简单点说:“一个接口，多种实现”。
#     指一个基类(父类)中派生出了不同的子类，且每个子类在继承了同样的方法名的同时又对父类的方法做了不同的实现，这就是同一种事物表现出的多种形态。
#     多态允许将子类的对象当作父类的对象使用，某父类型的引用指向其子类型的对象,调用的方法是该子类型的方法。
#     这里引用和调用方法的代码编译前就已经决定了,而引用所指向的对象可以在运行期间动态绑定。


# 3、说说python中所说的封装是什么意思？
# 封装
#     在类中对 数据的赋值、内部调用 对外部用户是透明的（这里透明的意思是类的外部不能调用这些数据，但是类的内部可以调用），
#     这使类变成了一个胶囊或容器，里面包含着类的数据和方法


# 4、多态是怎么回事？在python中是如何体现的？
# 多态：指的是一类事物有多种形态
# 动物有多种形态：人，狗，猪
# import abc
# class Animal(metaclass=abc.ABCMeta):  # 同一类事物：动物
#
#     @abc.abstractmethod
#     def talk(self):
#         pass
#
# class People(Animal):  # 动物形态之一：人
#     def talk(self):
#         print('say hello')
#
# class Dog(Animal):  # 动物的形态之二:狗
#     def talk(self):
#         print('say wangwangwang')
#
# class Pig(Animal): #动物的形态之三:猪
#     def talk(self):
#         print('say aoao')
#
#
# 多态性
# peo = People()
# dog = Dog()
# pig = Pig()

# peo、dog、pig都是动物,只要是动物肯定有talk方法
# 于是我们可以不用考虑它们三者的具体是什么类型,而直接使用
# peo.talk()
# dog.talk()
# pig.talk()

# 更进一步,我们可以定义一个统一的接口来使用
# def func(obj):
#     obj.talk()
# func(peo)
# func(dog)
# func(pig)




# 5、说说面向对象中“私有”的概念以及应用
# 有私有属性和私有方法，可以把不需要对外提供的内容和属性都隐藏起来，将变化隔离，便于应用，提高重用性，提高安全性。



# 6、在面向对象中有一些被装饰器装饰的方法，先说说有哪些装饰器，再说说这些装饰器的作用，以及装饰之后的效果
# property属性：改变一个方法的调用方式，把一个方法属性化，例如之前调用一个方法：obj.func() 加了property属性以后，可以用
# obj.func 调用
# classmethod方法：类方法，增加这个属性以后，可以直接由类调用方法，当然实例对象也可以调用此方法
# staticmethod方法：静态方法，不涉及到类属性和实例属性的时候使用，调用该方法的时候，不再需要传递self参数了，定义该方法的时候也没有self参数



# 7、请说明新式类和经典类的区别，至少两个
# 多重继承查找顺序不同，经典类按照深度优先的方法查找。新式类按照C3算法查找，即广度优先



# 8、请说出上面一段代码的输出并解释原因
#
# class Foo:
#     def func(self):
#         print('in father')
#
#
# class Son(Foo):
#     def func(self):
#         print('in son')
#
#
# s = Son()
# s.func()        # in son
# # 一个实例对象查找某个属性方法一定严格按照如下顺序
# # 实例对象的内存空间 ---> 实例对象对应的类空间里查找  ---> 实例对象对应的类空间的父类空间查找
